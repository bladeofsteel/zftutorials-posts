title: Некоторые советы, чтобы писать модули для Zend Framework 2 лучше
slug: some-tips-to-write-better-zend-framework-2-modules
category: modules
cite: Несколько полезных советов по написанию модулей для Zend Framework 2 с примерами из реальных модулей. Следуя этим не хитрым советам, можно значительно поднять качество ваших модулей. Мишель делится опытом, полученным на собственной "шкуре" при разработке собственных больших модулей и при использовании чужих модулей.  
<blockquote>Эта статья больше нацелена на новичков в ZF2, которые хотят осчастливить мир своими супер-пупер-фантастическими модулями … Я надеюсь, что эти несколько советов (некоторые действительно очевидные, но я встречаю слишком много модулей, которые не следуют даже простейшим правилам) будут вам полезны.</blockquote>
~~~~
__Источник:__ [Some tips to write better Zend Framework 2 modules][1]  
__Автор:__ [Michaël Gallego][2]  
__Перевод:__ [Лобач Олег][3]  

[1]: http://www.michaelgallego.fr/blog/2013/01/21/some-tips-to-write-better-zend-framework-2-modules/
[2]: http://www.michaelgallego.fr/blog/
[3]: http://lobach.info/

Update 4 февраля 2013 : добавлен новый совет о зависимостях

Во время работы над различными модулями для Zend Framework 2 (в настоящее время, моим самым большим проектом была работа над [ZfrRest][ZfrRest], цель которого предоставить полноценный REST-модуль), я по настоящему изучил множество вещей о PHP и о том, как писать хороший, защищенный и более гибкий код.

[ZfrRest]: https://github.com/zf-fr/ZfrRest

Эта статья больше нацелена на новичков в ZF2, которые хотят осчастливить мир своими супер-пупер-фантастическими модулями. Однако, если вы хотите, чтобы люди использовали его (и, следовательно, делали его лучше!), вам нужно предоставить что-то действительно хорошее. Я надеюсь, что эти несколько советов (некоторые действительно очевидные, но я встречаю слишком много модулей, которые не следуют даже простейшим правилам) будут вам полезны.

## Для этого уже есть модуль!

Прежде чем писать свой модуль, проверьте, не написал ли его уже кто-нибудь до вас! Вместо разработки собственного модуля, просто сделайте уже существующий модуль лучше, отправив свои улучшения в него. Вы можете проверить [ZF2.modules][zf2modules] и поискать модуль по ключевым словам!

[zf2modules]: http://modules.zendframework.com/

За более подробной информацией по этой теме обратитесь к [заметке Martin Shwalbe о модулях][MSpost].

[MSpost]: http://hounddog.github.com/blog/there-is-a-module-for-that/

## Следуйте соглашениям

Zend Framework 2, как и другие современные фреймворки, имеет строгие соглашения о кодировании. Естественно, фреймворк следует соглашениям PSR-0/1/2, и вы тоже должны это делать. Но у нас так же есть некоторые соглашения о том, где мы должны располагать некоторые файлы.

К примеру, многие модули могут конфигурироваться. Когда у вас много параметров, неплохой идеей будет собрать их в классе Options (который расширяет `Zend\Stdlib\AbstractOptions`). Это обычная практика для складирования всех этих файлов в каталоге  _“Options”_, чтобы каждый класс параметра обладал собственным пространством имен. Конечно, вы можете положить эти классы куда угодно, но то, как делаем мы, облегчает разработчикам чтение вашего кода, если эти классы будут находиться в предсказуемом месте.

Кроме того, я видел много людей, которые складывают много файлов в один каталог, просто чтобы не создавать новый каталог. Серьёзно, просто создавайте каталоги. Это никому не повредит, но поможет людям проще находить файлы. К примеру, если вы создаете постраничный адаптер, просто имитируйте структуру ZF2 и сохраните его в `YourModule\Paginator\Adapter\MySuperAdapter`, не в `YourModule\Form\Adapter\MySuperAdapter`, просто потому что вы поленились создать новый каталог :).

В качестве примера посмотрите [DoctrineModule options classes][doctrineclass].

[doctrineclass]: https://github.com/doctrine/DoctrineModule/tree/master/src/DoctrineModule/Options

## Разрешайте настраивать все, что должно настраиваться

Модули подразумевают совместное и повторное использование другими людьми. И люди не всегда имеют точно такие же потребности, что и вы. Всякий раз, когда нечто "может" быть изменено другими людьми, добавьте конфигурационный параметр, позволяющий изменить его. Например, если ваш модуль генерирует некоторую HTML страницу с определенными встроенными стилями, которые копируются из CSS-файла предоставляемого модулем... просто создайте способ, чтобы люди могли установить путь к их собственному CSS-файлу (таким образом, им не придется вручную настраивать CSS, поставляемый с вашим модулем).

Когда вы поставляете ваш модуль, вы должны поставить два файла в конфигурационном каталоге. Один файл называется “`module.config.php`” и предоставляет "стандартную" конфигурацию и конфигурацию, которая не должна модифицироваться другими пользователями, и другой файл, называемый  “`my_module.global.php.dist`”, который предоставляет все параметры, которые может переопределить пользователь (этот файл обычно копипастят в каталог `config/autoload` вашего приложения).

Отличный пример такого подхода [конфигурационный файл ZfcUser][zfcuserconfig]. Как вы видите, практически все можно переопределить, что делает модуль действительно гибким.

[zfcuserconfig]: https://github.com/ZF-Commons/ZfcUser/blob/master/config/zfcuser.global.php.dist

## Устанавливайте ваши жесткие зависимости в конструкторе, избегайте инициализаторов и сеттеров/геттеров

Сервис-локатор в Zend Framework 2 действительно позволяет прозрачно управлять сложными зависимостями... это действительно мощный инструмент, который не так уж сложен в применении, достаточно один раз понять, как он работает. Однако, ZF2 поставляется с чем то, что называется инициализаторы. Я абсолютно уверен, что вы уже сталкивались с ними. Например, ими являются `ServiceLocatorAwareInterface` или `EventManagerAwareInterface`… Когда класс реализует эти интерфейсы, сервис-менеджер автоматически внедрит (через сеттеры) зависимости.

Несмотря на удобство, этот способ страдает от одной проблемы, которая может принести много боли пользователям вашего модуля. К примеру, в ZfrRest у нас есть классы, которые используются для разбора объектов HTTP-запросов/ответов. Все эти парсеры расширяют абстрактный класс, называемый AbstractParser. Вы можете увидеть [этот класс тут][abstractparser].

[abstractparser]: https://github.com/zf-fr/ZfrRest/blob/master/src/ZfrRest/Http/Parser/AbstractParser.php

В качестве примера, посмотрите на конструктор:

<pre class="lang:php"><code>
public function __construct(DecoderPluginManager $pluginManager)
{
    $this->decoderPluginManager = $pluginManager;
}
</code></pre>

Вместо конструктора мы можем написать сеттер/геттер для установки `DecoderPluginManager` и внедрения зависимости через сервис-менеджер или используя инициализатор. НО, это предполагает, что ваши пользователи фактически будут использовать сервис-менеджер для создания вашего объекта.

Пока однажды кто-нибудь не создаст парсер таким образом:

<pre class="lang:php"><code>
$parser = new BodyParser();
$parser->parse($request);
</code></pre>

И бум! Он не вызвал `setDecoderPluginManager` как и не создал экземпляр через сервис-менеджер. Зависимость корректно не установлена, и этот код выбросит исключение.

ПОТОМУ ЧТО `DecoderPluginManager` это необходимая зависимость этого объекта (он не может работать без этой зависимости), просто попросите устанавливать зависимость непосредственно через конструктор. Это не позволит людям использовать ваш объект не правильно. Даже если они захотят.

## Уменьшайте использование замыканий в пользу фабрик

В ZF2 общеупотребимой практикой является управление зависимостями через использование замыканий в качестве фабрик в методе `getServiceConfig` вашего класса `Module.php`. Вместо этого, вам лучше использовать явные фабричные классы и применять их при определении фабрик в файле `module.config.php` (в секции service_manager). Это несколько эффективней (потому что создается экземпляр замыкания, строку создать быстрее, нежели замыкание), позволяет кэшировать конфигурационный файл (замыкание кэшировать нельзя) и делает `Module.php` более читаемым, т.к. удаляет тонны кода замыканий.

<pre class="lang:php"><code>
return array(
    'service_manager' => array(
        'factories' => array(
            'MyModule\My\Service' => 'MyModule\Service\MyServiceFactory'
        )
    )
);
</code></pre>

## Для внесения зависимостей используйте сервис-менеджер где только возможно

Этот совет близко соседствует с "позволяйте настраивать что угодно". Иногда люди действительно хотят на самом деле странных вещей. Поверьте мне. Вы иногда спрашиваете себя: "за каким чертом вам понадобилась эта возможность?". Однако они хотят. Конечно, вы не хотите добавлять эту возможность в ядро вашего модуля потому, что вы все еще хотите пнуть по заднице этого парня за предложение такой странной штуки, но по крайней мере вы должны сделать для него максимально легким переопределение чего угодно.

И благодаря архитектуре ZF 2, это сделать действительно просто: создавайте большинство ваших объектов через сервис-менеджер. Например, в ZfrRest мы добавили некоторые слушатели, которые предоставляют полезные возможности в контексте REST. Первый способ - это просто сделать так:

<pre class="lang:php"><code>
public function onBootstrap(EventInterface $e)
{
    $application     = $e->getTarget();
    $serviceManager  = $application->getServiceManager();
    $eventManager    = $application->getEventManager();

    $eventManager->attach(new ZfrRest\Mvc\HttpExceptionListener());
}</code></pre>

Однако, подумайте о тех странных парнях, которые хотят еще посылать письма своей бабушке когда будет выброшено исключение. Как он может это сделать сейчас? Ну... он может изменить код вашего модуля, но это не слишком хорошая затея, т.к. когда он захочет обновить ваш модуль, ему придется повторить изменения снова.

К счастью, использование сервис-менеджера решает эту проблему:

<pre class="lang:php"><code>
public function onBootstrap(EventInterface $e)
{
    $application     = $e->getTarget();
    $serviceManager  = $application->getServiceManager();
    $eventManager    = $application->getEventManager();

    $eventManager->attach($serviceManager->get('ZfrRest\Mvc\HttpExceptionListener'));
}
</code></pre>

Теперь слушатель достается из сервис-менеджера. Конечно, в ZfrRest есть реализация по умолчанию этого листенера, добавленная в настройки сервис-менеджера:

<pre class="lang:php"><code>
// in the module.config.php
return array(
    'service_manager' => array(
        'invokables' => array(
           'ZfrRest\Mvc\HttpExceptionListener' => 'ZfrRest\Mvc\HttpExceptionListener'
        )
    )
);
</code></pre>

Теперь если кто-то захочет заменить слушатель, ему просто нужно изменить параметр в собственном конфигурационном файле:

<pre class="lang:php"><code>
// in the module.config.php
return array(
    'service_manager' => array(
        'invokables' => array(
           'ZfrRest\Mvc\HttpExceptionListener' => 'MyModule\Mvc\SendBananaListener'
        )
    )
);
</code></pre>

## Пишите модульные тесты

Пишите модульные тесты для вашего модуля (да, это скучно). Я уже использовал модули без тестов и это была настоящая боль в заднице. Когда я обновлял их, мое остальное приложение падало, потому что обновление что-то ломало. Это тем более важно для модулей, которые люди хотят использовать профессионально. Если они не покрыты тестами, к ним и близко не подойдут.

Еще раз, **пишите модульные тесты для своих модулей**. И точка.

## Размещайте ваш модуль на Packagist (для использования Composer) и zf.modules

Многие используют Composer для управления зависимостями между модулями. Хотя вы можете его ненавидеть, просто помните, что многие люди его любят. Так что опубликуйте ваш модуль на Packagist, если вы считаете его достаточно хорошим.

К тому же, вы можете добавить ваш модуль на страницу [ZF2.modules][zf2modules].

Если у вас есть другие советы, не стесняйтесь!