Вначале очень краткий ликбез. Механизм поддержки различных языков в `ZendFramework` реализована в виде компонента [Zend_Translate][4]. Он поддерживает массу различных форматов хранения переводов: array, csv, gettext, ini, tbx, tmx, qt, xliff, xmltm. За описаниями особенностей форматов я отправлю в руководство разработчике — [Adapters for Zend_Translate][5]. Настройка `Zend_Translate` на тот или иной формат выполняется с помощью подключения соответствующего адаптера. На этом, думаю, с вводной частью я закончу и покажу, как использовать `Zend_Translate`.

 [4]: http://framework.zend.com/manual/en/zend.translate.html
 [5]: http://framework.zend.com/manual/en/zend.translate.adapter.html

Простейший способ использования компонента заключается в создании экземпляра этого класса в загрузочном файле:

<pre><code name="php"><?php

$translate = new Zend_Translate('gettext',
                                '/path/to/translate.mo',
                                'en');

Zend_Registry::set('Zend_Translate', $translate);</code></pre>

Такое действие даст вам возможность в любом месте приложения получить из реестра экземпляр переводчика и с его помощью получить текст на нужном языке

Теперь давайте посмотрим, что предлагает автор статьи, указанной в начале этой заметки. А он предлагает вместо настройки `Zend_Translate` в загрузочном файле сделать это с помощью [плагина контроллера][6]. Его вариант я приводить не буду (интересующиеся могут пройти по ссылке и посмотреть самостоятельно), укажу лишь на то, что настройка компонента зашивается намертво в код плагина. Если вы всегда и везде используете одни и те же параметры, то такой вариант вполне вам может подойти. Если же настройки меняются от приложения к приложению, либо если хочется воспользоваться более универсальным решением, то предлагаю посмотреть на мой вариант.

 [6]: http://framework.zend.com/manual/en/zend.controller.plugins.html

Код плагина приводить не буду — он доступен по ссылке в конце статьи. Опишу лишь отличия и покажу пример использования.

В отличии от предыдущего варианта, мой вариант достаточно гибко настраивается: плагин может регистрировать в приложении как уже существующий экземпляр `Zend_Translate`, так и создавать новый экземпляр по переданным в плагин параметрам. Так же можно не регистрировать экземпляр переводчика в реестре, и при этом доступ к нему сохранится через методы плагина. Текущий язык приложения определяется через параметр запроса. По-умолчанию параметр называется `lang`, но его можно поменять при инициализации плагина

Спецификация конструктора следующая:

<pre><code name="php">
public function __construct(array $options = array(),
                            Zend_Translate $translate = null,
                            Zend_Locale $locale = null, $skipRegistry = false);
</code></pre>

Входные параметры:

*   $options — массив параметров для инициализации экземпляра `Zend_Translate`. Элементы массива идентичны параметрам конструктора `Zend_Translate`:</p> 
    *   `adapter` — используемый адаптер
    *   `data` — данные для адаптера
    *   `locale` — используемая локаль
    *   `options` — параметры конфигурации `Zend_Translate`
    *   `langKey` — этот параметр относится уже непосредственно к плагину и определяет название параметра запроса, содержащего указание на запрашиваемый язык
*   `$translate` — экземпляр класса `Zend_Translate`
*   `$locale` — экземпляр класса `Zend_Locale` (может потребоваться если нужно указать язык, отличный от указанного в запросе)

Вот один из вариантов использования. Допустим, что параметры настройки переводчика хранятся в файле конфигурации приложения:

<pre><code name="php"><?php

$config = new Zend_Config_Ini('/path/to/config.ini');
Zend_Controller_Front::getInstance()
    ->registerPlugin(new Zeus_Controller_Plugin_Language($config->translate));</code></pre>

Вот и все! Локаль настроена, переводчик инициализирован и готов к употреблению

Остановлюсь на еще одном моменте. Плагин в результате работы регистрирует экземпляр локали и переводчика в реестре использую стандартные ключи: `Zend_Locale` и `Zend_Translate` соответственно. Такое решение, помимо доступности объектов в любом месте приложения, позволяет воспользоваться стандартными помощниками вида и помощниками действий:

<pre><code name="php">
$this->view->title = $this->view->translate('default-register-index-title');
</code></pre>

<pre><code name="php">
<?php echo $this->translate('default-register-index-title'); ?>
</code></pre>

Код плагина можно взять на [GitHub][7]-е.

 [7]: https://github.com/bladeofsteel/language-plugin/blob/master/App/Controller/Plugin/Language.php

Постараюсь ответить на все вопросы и оказать посильную помощь. Поэтому не стесняйтесь и оставляйте свои комментарии. Предложения по усовершенствованию также приветствуются...

P.S.: Вчера вышел ZendFramework 1.7.2. Посмотреть исправления можно по адресу <http://framework.zend.com/issues/secure/views/IssueNavigator.jspa?requestId=10923>. Последний релиз, как всегда, берем <http://framework.zend.com/download/latest/>.

P.P.S.: Хочу порекомендовать блог Романа Настенко «[Перфектомания][8]». Роман пишет на темы, связанные с разработкой сайтов: юзабилити, проектирование, SMO. Читаю его давно и с интересом.

 [8]: http://www.perfectomania.com/